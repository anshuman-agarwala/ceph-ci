#pragma once

#include <array>
#include <string>
#include <memory>
#include "include/ceph_assert.h"

#include "OpType.h"

/* Overview
 *
 * class IoOp
 *   Stores details for an I/O operation. Generated by IoSequences
 *   and applied by IoExerciser's
 */

namespace ceph {
  namespace io_exerciser {

    class IoOp
    {
      public:
        IoOp();
        virtual ~IoOp() = default;
        virtual std::string to_string(uint64_t block_size) const = 0;
        virtual constexpr OpType getOpType() const = 0;
    };

    template<OpType opType>
    class TestOp : public IoOp
    {
      public:
        TestOp();
        constexpr OpType getOpType() const override { return opType; }
    };

    class DoneOp : public TestOp<OpType::Done>
    {
      public:
        DoneOp();
        static std::unique_ptr<DoneOp> generate();
        std::string to_string(uint64_t block_size) const override;
    };

    class BarrierOp : public TestOp<OpType::Barrier>
    {
      public:
        BarrierOp();
        static std::unique_ptr<BarrierOp> generate();
        std::string to_string(uint64_t block_size) const override;
    };

    class CreateOp : public TestOp<OpType::Create>
    {
      public:
        CreateOp(uint64_t size);
        static std::unique_ptr<CreateOp> generate(uint64_t size);
        std::string to_string(uint64_t block_size) const override;
        uint64_t size;
    };

    class RemoveOp : public TestOp<OpType::Remove>
    {
      public:
        RemoveOp();
        static std::unique_ptr<RemoveOp> generate();
        std::string to_string(uint64_t block_size) const override;
    };

    template<OpType opType, int numIOs>
    class ReadWriteOp : public TestOp<opType>
    {
      public:
        std::array<uint64_t, numIOs> offset;
        std::array<uint64_t, numIOs> length;

      protected:
        ReadWriteOp(std::array<uint64_t, numIOs>&& offset,
                    std::array<uint64_t, numIOs>&& length);
        std::string to_string(uint64_t block_size) const override;
    };

    class SingleReadOp : public ReadWriteOp<OpType::Read, 1>
    {
      public:
        SingleReadOp(uint64_t offset, uint64_t length);
        static std::unique_ptr<SingleReadOp> generate(uint64_t offset,
                                                      uint64_t length);
    };

    class DoubleReadOp : public ReadWriteOp<OpType::Read2, 2>
    {
      public:
        DoubleReadOp(uint64_t offset1, uint64_t length1,
                     uint64_t offset2, uint64_t length2);
        static std::unique_ptr<DoubleReadOp> generate(uint64_t offset1,
                                                      uint64_t length1,
                                                      uint64_t offset2,
                                                      uint64_t length2);
    };

    class TripleReadOp : public ReadWriteOp<OpType::Read3, 3>
    {
      public:
        TripleReadOp(uint64_t offset1, uint64_t length1,
                     uint64_t offset2, uint64_t length2,
                     uint64_t offset3, uint64_t length3);
        static std::unique_ptr<TripleReadOp> generate(uint64_t offset1,
                                                      uint64_t length1,
                                                      uint64_t offset2,
                                                      uint64_t length2,
                                                      uint64_t offset3,
                                                      uint64_t length3);
    };

    class SingleWriteOp : public ReadWriteOp<OpType::Write, 1>
    {
      public:
        SingleWriteOp(uint64_t offset, uint64_t length);
        static std::unique_ptr<SingleWriteOp> generate(uint64_t offset,
                                                       uint64_t length);
    };

    class DoubleWriteOp : public ReadWriteOp<OpType::Write2, 2>
    {
      public:
        DoubleWriteOp(uint64_t offset1, uint64_t length1,
                      uint64_t offset2, uint64_t length2);
        static std::unique_ptr<DoubleWriteOp> generate(uint64_t offset1,
                                                       uint64_t length1,
                                                       uint64_t offset2,
                                                       uint64_t length2);
    };

    class TripleWriteOp : public ReadWriteOp<OpType::Write3, 3>
    {
      public:
        TripleWriteOp(uint64_t offset1, uint64_t length1,
                      uint64_t offset2, uint64_t length2,
                      uint64_t offset3, uint64_t length3);
        static std::unique_ptr<TripleWriteOp> generate(uint64_t offset1,
                                                       uint64_t length1,
                                                       uint64_t offset2,
                                                       uint64_t length2,
                                                       uint64_t offset3,
                                                       uint64_t length3);
    };
  }
}