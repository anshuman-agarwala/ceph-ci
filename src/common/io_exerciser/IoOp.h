#pragma once

#include <array>
#include <optional>
#include <string>
#include <memory>
#include "include/ceph_assert.h"

#include "OpType.h"

/* Overview
 *
 * class IoOp
 *   Stores details for an I/O operation. Generated by IoSequences
 *   and applied by IoExerciser's
 */

namespace ceph {
  namespace io_exerciser {

    class IoOp
    {
      public:
        IoOp();
        virtual ~IoOp();
        virtual std::string to_string(uint64_t block_size) const = 0;
        virtual constexpr OpType getOpType() const = 0;
    };

    template<ceph::io_exerciser::OpType opType>
    class TestOp : public IoOp
    {
      public:
        TestOp();
        constexpr OpType getOpType() const override { return opType; }
    };

    class DoneOp : public TestOp<ceph::io_exerciser::OpType::Done>
    {
      public:
        DoneOp();
        static std::unique_ptr<DoneOp> generate();
        std::string to_string(uint64_t block_size) const override;
    };

    class BarrierOp : public TestOp<ceph::io_exerciser::OpType::Barrier>
    {
      public:
        BarrierOp();
        static std::unique_ptr<BarrierOp> generate();
        std::string to_string(uint64_t block_size) const override;
    };

    class CreateOp : public TestOp<ceph::io_exerciser::OpType::Create>
    {
      public:
        CreateOp(uint64_t size);
        static std::unique_ptr<CreateOp> generate(uint64_t size);
        std::string to_string(uint64_t block_size) const override;
        uint64_t size;
    };

    class RemoveOp : public TestOp<ceph::io_exerciser::OpType::Remove>
    {
      public:
        RemoveOp();
        static std::unique_ptr<RemoveOp> generate();
        std::string to_string(uint64_t block_size) const override;
    };

    template<ceph::io_exerciser::OpType opType, int numIOs>
    class ReadWriteOp : public TestOp<opType>
    {
      public:
        ReadWriteOp(std::array<uint64_t, numIOs> offset,
                    std::array<uint64_t, numIOs> length);

        std::string to_string(uint64_t block_size) const override;

        std::array<uint64_t, numIOs> offset;
        std::array<uint64_t, numIOs> length;
    };

    class SingleReadOp : public ReadWriteOp<ceph::io_exerciser::OpType::Read, 1>
    {
      public:
        SingleReadOp(uint64_t offset, uint64_t length);
        static std::unique_ptr<SingleReadOp> generate(uint64_t offset,
                                                      uint64_t length);
    };

    class DoubleReadOp : public ReadWriteOp<ceph::io_exerciser::OpType::Read2, 2>
    {
      public:
        DoubleReadOp(uint64_t offset1, uint64_t length1,
                     uint64_t offset2, uint64_t length2);
        static std::unique_ptr<DoubleReadOp> generate(uint64_t offset1,
                                                      uint64_t length1,
                                                      uint64_t offset2,
                                                      uint64_t length2);
    };

    class TripleReadOp : public ReadWriteOp<ceph::io_exerciser::OpType::Read3, 3>
    {
      public:
        TripleReadOp(uint64_t offset1, uint64_t length1,
                     uint64_t offset2, uint64_t length2,
                     uint64_t offset3, uint64_t length3);
        static std::unique_ptr<TripleReadOp> generate(uint64_t offset1,
                                                      uint64_t length1,
                                                      uint64_t offset2,
                                                      uint64_t length2,
                                                      uint64_t offset3,
                                                      uint64_t length3);
    };

    class SingleWriteOp : public ReadWriteOp<ceph::io_exerciser::OpType::Write, 1>
    {
      public:
        SingleWriteOp(uint64_t offset, uint64_t length);
        static std::unique_ptr<SingleWriteOp> generate(uint64_t offset,
                                                       uint64_t length);
    };

    class DoubleWriteOp : public ReadWriteOp<ceph::io_exerciser::OpType::Write2, 2>
    {
      public:
        DoubleWriteOp(uint64_t offset1, uint64_t length1,
                      uint64_t offset2, uint64_t length2);
        static std::unique_ptr<DoubleWriteOp> generate(uint64_t offset1,
                                                       uint64_t length1,
                                                       uint64_t offset2,
                                                       uint64_t length2);
    };

    class TripleWriteOp : public ReadWriteOp<ceph::io_exerciser::OpType::Write3, 3>
    {
      public:
        TripleWriteOp(uint64_t offset1, uint64_t length1,
                      uint64_t offset2, uint64_t length2,
                      uint64_t offset3, uint64_t length3);
        static std::unique_ptr<TripleWriteOp> generate(uint64_t offset1,
                                                       uint64_t length1,
                                                       uint64_t offset2,
                                                       uint64_t length2,
                                                       uint64_t offset3,
                                                       uint64_t length3);
    };

    template <ceph::io_exerciser::OpType opType>
    class InjectErrorOp : public TestOp<opType>
    {
      public:
        InjectErrorOp(int shard, std::optional<int> type, std::optional<int> when, std::optional<int> duration);

        std::string to_string(uint64_t block_size) const override;

        int shard;
        std::optional<int> type;
        std::optional<int> when;
        std::optional<int> duration;

      protected:
        virtual constexpr std::string_view get_inject_type_string() const = 0;
    };

    class InjectReadErrorOp : public InjectErrorOp<OpType::InjectReadError>
    {
      public:
        InjectReadErrorOp(int shard, std::optional<int> type, std::optional<int> when, std::optional<int> duration);

        static std::unique_ptr<InjectReadErrorOp> generate(int shard,
                                                           std::optional<int> type,
                                                           std::optional<int> when,
                                                           std::optional<int> duration);

      protected:
        constexpr std::string_view get_inject_type_string() const override;
    };

    class InjectWriteErrorOp : public InjectErrorOp<OpType::InjectWriteError>
    {
      public:
        InjectWriteErrorOp(int shard, std::optional<int> type, std::optional<int> when, std::optional<int> duration);

        static std::unique_ptr<InjectWriteErrorOp> generate(int shard,
                                                            std::optional<int> type,
                                                            std::optional<int> when,
                                                            std::optional<int> duration);

      protected:
        constexpr std::string_view get_inject_type_string() const override;
    };

    template <ceph::io_exerciser::OpType opType>
    class ClearErrorInjectOp : public TestOp<opType>
    {
      public:
        ClearErrorInjectOp(int shard, std::optional<int> type);

        std::string to_string(uint64_t block_size) const override;

        int shard;
        std::optional<int> type;

      protected:
        virtual constexpr std::string_view get_inject_type_string() const = 0;
    };

    class ClearReadErrorInjectOp : public ClearErrorInjectOp<OpType::ClearReadErrorInject>
    {
      public:
        ClearReadErrorInjectOp(int shard, std::optional<int> type);

        static std::unique_ptr<ClearReadErrorInjectOp> generate(int shard,
                                                                std::optional<int> type);

      protected:
        constexpr std::string_view get_inject_type_string() const override;
    };

    class ClearWriteErrorInjectOp : public ClearErrorInjectOp<OpType::ClearWriteErrorInject>
    {
      public:
        ClearWriteErrorInjectOp(int shard, std::optional<int> type);

        static std::unique_ptr<ClearWriteErrorInjectOp> generate(int shard,
                                                                 std::optional<int> type);

      protected:
        constexpr std::string_view get_inject_type_string() const override;
    };
  }
}